;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;; WATTAGE METER VERSION 1.0 ;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PROCESSOR '16F876A'
	INCLUDE <P16F876A.INC>

	__CONFIG _XT_OSC & _WDT_OFF & _PWRTE_OFF & _CP_OFF & _LVP_OFF & _BODEN_OFF

	CBLOCK 0x20

;DIVISION VARIABLES
NUMERATOR:4 ;USE 4 BYTES WITH SAME LABEL (0x20, 0x21, 0x22, 0x23)
REMAINDER ;THE REMAINDER (0x24)
LCNT ;LOOP COUNTER (0x25)

;CONVERTION VARIABLES
CONVL ;CONVERTION CONSTANT LOW BYTE (0x26)
CONVH ;CONVERTION CONSTANT HIGH BYTE (0x27)
CONVRESL ;TEMP VAR FOR ADRESL (0x28)
CONVRESH ;TEMP VAR FOR ADRESH (0x29)
V0 ;CONV TO VOLTS RES BYTE 0 (0x2A)
V1 ;CONV TO VOLTS RES BYTE 1 (0x2B)
V2 ;CONV TO VOLTS RES BYTE 2 (0x2C)
V3 ;CONV TO VOLTS RES BYTE 2 (0x2D)

;RESULT
V_ASCII_0 ;0,001 V (0x2E)
V_ASCII_1 ;0,010 V (0x2F)
V_ASCII_2 ;0,100 V (0x30)
V_ASCII_3 ;1,000 V (0x31)

;GENERAL USE REGISTERS
CNT0 ;(0x32)
CNT1 ;(0x33)
CNT2 ;(0x34)

TMP ;(0x35)

ANIN1L ;(0x36)
ANIN1H ;(0x37)
ANIN2L ;(0x38)
ANIN2H ;(0x39)

CCL ;(0x3A)
CCH ;(0x3B)

INPUT_PIN  ;(0x3C)
	ENDC

;CONVERTION CONSTANTS

CCLV EQU 0x18 ;VOLTAGE CONVERTION CONSTANT LOW BYTE
CCHV EQU 0x13 ;VOLTAGE CONVERTION CONSTANT HIGH BYTE (4888) (AN2)

CCLA0 EQU 0x55 ;AMPS CONVERTION CONSTANT LOW BYTE
CCHA0 EQU 0x10 ;AMPS CONVERTION CONSTANT HIGH BYTE (4181) (AN0)

CCLA1 EQU 0xEC ;AMPS CONVERTION CONSTANT LOW BYTE
CCHA1 EQU 0x13 ;AMPS CONVERTION CONSTANT HIGH BYTE (5100) (AN1)



MODE_BTN EQU 4 ;BIT 4, PORT A

;ANALOG CHANNELS
HALL0_IN EQU B'01000001' ;ADCON0 TO SET ANALOG CHANNEL 0
HALL1_IN EQU B'01001001' ;ADCON0 TO SET ANALOG CHANNEL 1
VOLTAGE_IN EQU B'01010001' ;ADCON0 TO SET ANALOG CHANNEL 2



	ORG 0x000
	GOTO INIT ;INCLUDE THE LCD DRIVER, AND OTHER FILES AND GOTO INIT ROUTINE
	INCLUDE <LCD_DRIVER.INC>
	INCLUDE <ADC.INC>
	INCLUDE <ANALOG_PROC.INC>

INIT:
	CALL LCD_INIT ;FIRST OF ALL WE HAVE TO INITIALIZE LCD (IT ALSO SETS PORTB AS OUTPUT, FOR MORE INFO CHECK THE .INC FILES)
		
	BSF STATUS, 5 ;SELECT BANK 01
	
	;PORTA IS SET TO INPUT MODE
	MOVLW B'11111111'
	MOVWF TRISA

	BCF STATUS, 5 ;SELECT BANK 00
	
MAIN:
	BTFSC PORTA, MODE_BTN ;CHECK IF INIT MODE BUTTON HAVE BEEN PRESSED
	CALL INIT_MODE

	;;;START OF VOLTS READING;;;
	
	MOVLW VOLTAGE_IN ;ANALOG CHANNEL 2
	CALL ADC_INIT ;INIT ADC MODULE
	CALL ADC_READ ;READ ANALOG VALUE AND STORE TO CONVRES REGISTER

	;CHECK IF CONVRES IS ZERO
	MOVF CONVRESL, W
	IORLW 0x00
	BTFSS STATUS, Z
	GOTO CONTINUE_0 ;IF NOT ZERO

	MOVF CONVRESH, W
	IORLW 0x00
	BTFSS STATUS, Z
	GOTO CONTINUE_0 ;IF NOT ZERO
	
	CALL CLRDIGITS ;ELSE
	GOTO OUTPUT
	
CONTINUE_0:
	CALL CONVERT_VOLTAGE_TO_ASCII

OUTPUT:
	MOVF V_ASCII_3, W
	CALL LCD_CHAR
	
	MOVLW '.'
	CALL LCD_CHAR
	
	MOVF V_ASCII_2, W
	CALL LCD_CHAR
	
	MOVF V_ASCII_1, W
	CALL LCD_CHAR
	
	MOVF V_ASCII_0, W
	CALL LCD_CHAR
	
	MOVLW 'V'
	CALL LCD_CHAR
	
	MOVLW 0x20
	CALL LCD_CHAR
	
	;;;END OF VOLTS READING;;;
	
	;;;START OF AMPS READING;;;
	
	;READ THE ANALOG PIN HALL0_IN
	MOVLW HALL0_IN  ;SET ANALOG CHANNEL 0
	CALL ADC_INIT ;INIT ADC MODULE
	CALL ADC_READ ;READ ANALOG VALUE AND STORE TO CONVRES REGISTER
	
	MOVF CONVRESL, W
	MOVWF ANIN1L
	MOVF CONVRESH, W
	MOVWF ANIN1H
	
	;READ THE ANALOG PIN HALL1_IN
	MOVLW HALL1_IN  ;SET ANALOG CHANNEL 1
	CALL ADC_INIT ;INIT ADC MODULE
	CALL ADC_READ ;READ ANALOG VALUE AND STORE TO CONVRES REGISTER
	
	;CHECK IF BOTH READINGS ARE ZERO
	MOVF CONVRESL, W
	MOVWF ANIN2L
	MOVF CONVRESH, W
	MOVWF ANIN2H
	
	MOVF ANIN1L, W
	IORLW 0x00
	BTFSS STATUS, Z
	GOTO CONTINUE_1 ;IF NOT ZERO
	MOVF ANIN1H, W
	IORLW 0x00
	BTFSS STATUS, Z
	GOTO CONTINUE_1 ;IF NOT ZERO

	MOVF ANIN2L, W
	IORLW 0x00
	BTFSS STATUS, Z
	GOTO CONTINUE_1 ;IF NOT ZERO
	MOVF ANIN2H, W
	IORLW 0x00
	BTFSS STATUS, Z
	GOTO CONTINUE_1 ;IF NOT ZERO
	
	CALL CLRDIGITS ;ELSE
	GOTO OUTPUT_1

CONTINUE_1:	
	CALL CONVERT_AMPS_TO_ASCII	;CONVERT AMPS TO ASCII
	
OUTPUT_1:
	MOVF V_ASCII_3, W
	CALL LCD_CHAR
	
	MOVLW '.'
	CALL LCD_CHAR
	
	MOVF V_ASCII_2, W
	CALL LCD_CHAR
	
	MOVF V_ASCII_1, W
	CALL LCD_CHAR
	
	MOVF V_ASCII_0, W
	CALL LCD_CHAR
	
	MOVLW 'A'
	CALL LCD_CHAR
	
	CALL LCD_L1
	
	GOTO MAIN

;
;CLEAR LCD DIGITS
;
CLRDIGITS:
	MOVLW 0x30
	MOVWF V_ASCII_0
	MOVWF V_ASCII_1
	MOVWF V_ASCII_2
	MOVWF V_ASCII_3

	RETURN

;
;INIT MODE
;
INIT_MODE:
	CALL LCD_CLR ;CLEAR DISPLAY
	CALL LCD_L1 ;GOTO START OF ROW
	
INIT_MODE_0:
	CLRF NUMERATOR + 0
	CLRF NUMERATOR + 1
	CLRF NUMERATOR + 2
	
	;READ THE ANALOG PIN HALL0_IN
	MOVLW HALL0_IN  ;SET ANALOG CHANNEL 0
	CALL ADC_INIT ;INIT ADC MODULE
	CALL ADC_READ ;READ ANALOG VALUE AND STORE TO CONVRES REGISTER
	
	MOVF CONVRESL, W
	MOVWF ANIN1L
	MOVF CONVRESH, W
	MOVWF ANIN1H
	
	;READ THE ANALOG PIN HALL1_IN
	MOVLW HALL1_IN  ;SET ANALOG CHANNEL 1
	CALL ADC_INIT ;INIT ADC MODULE
	CALL ADC_READ ;READ ANALOG VALUE AND STORE TO CONVRES REGISTER
	
	MOVF CONVRESL, W
	MOVWF ANIN2L
	MOVF CONVRESH, W
	MOVWF ANIN2H

	
	;SUB THE HIGH BYTES OF 2 READINGS
	MOVF ANIN1L, W
	SUBWF ANIN2L, W
	MOVWF NUMERATOR + 0
	BTFSS STATUS, C
	DECF ANIN2H
	
	;SUB THE LOW BYTES
	MOVF ANIN1H, W
	SUBWF ANIN2H, W
	MOVWF NUMERATOR + 1
	
	;IF THE SUBTRUCTOR IS > THAN THE SUBTRACTIVE
	;FIRST WE CHECK THE HIGH BYTE
	MOVF ANIN1H, W
	SUBWF ANIN2H, W
	BTFSS STATUS, C
	GOTO COMH
	
	;AND IF FALSE, THEN WE CHECK AND THE LOW BYTE
	MOVF ANIN1L, W
	SUBWF ANIN2L, W
	BTFSS STATUS, C
	GOTO COML
	GOTO NOCOM

	;THEN WE HAVE TO TAKE THE COMPLEMENT, BECAUSE WE NEED AN ABSOLUTE VALUE AND NOT A NEGATIVE NUM
COML:
	COMF NUMERATOR + 0, F
COMH:
	COMF NUMERATOR + 1, F
	INCF NUMERATOR + 0
	
	;IF WE DONT HAVE A NEGATIVE CONVERT TO ASCII AND OUTPUT TO THE LCD
NOCOM:
	MOVLW B'00000011'
	ANDWF NUMERATOR + 1, F
	
	CALL CONVERT2ASCII
	
INIT_OUTPUT:
	MOVF V_ASCII_3, W
	CALL LCD_CHAR
	
	MOVF V_ASCII_2, W
	CALL LCD_CHAR
	
	MOVF V_ASCII_1, W
	CALL LCD_CHAR
	
	MOVF V_ASCII_0, W
	CALL LCD_CHAR

	CALL LCD_L1
	
	BTFSC PORTA, MODE_BTN
	GOTO INIT_MODE_0
	
	RETURN
	
	END