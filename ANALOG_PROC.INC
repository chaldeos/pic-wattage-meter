;
;CONVERTS THE ANALOG READING FOR VOLTAGE TO VOLTS AND THEN RETURNS THEM TO 5 REGISTERS
;
CONVERT_VOLTAGE_TO_ASCII:
	CLRF V0
	CLRF V1
	CLRF V2
	CLRF V3
	
	MOVLW CCLV
	MOVWF CCL
	MOVLW CCHV
	MOVWF CCH
	
	CALL AN2NUM

	MOVF V0, W
	MOVWF NUMERATOR + 0
	MOVF V1, W
	MOVWF NUMERATOR + 1
	MOVF V2, W
	MOVWF NUMERATOR + 2
	MOVF V3, W
	MOVWF NUMERATOR + 3
	
	CALL DIVBY10 ;DISCARD
	CALL DIVBY10 ;THE LAST
	CALL DIVBY10 ;THREE DIGITS
	
	;SAVE THE 16BIT VOLTAGE NUM TO FIND AFTER THE WATTAGE
	MOVF  NUMERATOR + 0, W
	MOVWF VOLTAGE + 0
	MOVF  NUMERATOR + 1, W
	MOVWF VOLTAGE + 1

	CALL CONVERT2ASCII
	
	RETURN

;
;CONVERTS THE ANALOG READING FOR CURRENT TO AMPS AND THEN RETURNS THEM TO 5 REGISTERS
;
CONVERT_AMPS_TO_ASCII:	
	
	;INITIALIZING, NUMERATOR + 1 <-- ANIN1H, NUMERATOR + 0 <-- ANIN1L
	MOVF ANIN1H, W
	MOVWF CONVRESH
	MOVF ANIN1L, W
	MOVWF CONVRESL
	MOVLW D'2'	;INITIALING INPUT_PIN = DEC '1'
	MOVWF INPUT_PIN

	;WE ARE CHECKING IF HIGH BYTES ARE EQUAL
	MOVF ANIN1H, W
	IORWF ANIN2H, W ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	BTFSC STATUS, Z	
	GOTO LOW_BYTE ;IF THEY ARE EQUAL, WE ARE CHECKING LOW BYTES
	
	;IF THEY ARE NOT EQUAL --> SUB THE HIGH BYTES OF 2 READINGS
	MOVF ANIN1H, W
	SUBWF ANIN2H, W
	BTFSS STATUS, C
	GOTO OK	; IF ANIN1H > ANIN2H GOTO OK

	MOVF ANIN2H, W	; IF ANIN2H > ANIN1H GOTO LOW_BYTE
	MOVWF CONVRESH
	MOVF ANIN2L, W
	MOVWF CONVRESL
	DECFSZ INPUT_PIN
	GOTO OK
	
	;SUB THE LOW BYTES TO FIND WHICH ONE IS BIGGER
LOW_BYTE:
	BCF STATUS, C
	MOVF ANIN1L, W
	SUBWF ANIN2L, W
	BTFSS STATUS, C
	GOTO OK
	MOVF ANIN2H, W	
	MOVWF CONVRESH	
	MOVF ANIN2L, W
	MOVWF CONVRESL
	DECFSZ INPUT_PIN
	

	;CONVERT TO ASCII AND OUTPUT TO THE LCD
OK:
	MOVLW B'00000011'
	ANDWF CONVRESH
	
	DECFSZ INPUT_PIN
	GOTO INPUT_PIN_A0
	
INPUT_PIN_A1:
	MOVLW CCLA1
	MOVWF CCL
	MOVLW CCHA1
	MOVWF CCH
	MOVLW '-'
	MOVWF SIGN

	GOTO CONTINUE_2
	
INPUT_PIN_A0:
	MOVLW CCLA0
	MOVWF CCL
	MOVLW CCHA0
	MOVWF CCH

CONTINUE_2:
	CLRF V0
	CLRF V1
	CLRF V2
	CLRF V3
	
	CALL AN2NUM

	MOVF V0, W
	MOVWF NUMERATOR + 0
	MOVF V1, W
	MOVWF NUMERATOR + 1
	MOVF V2, W
	MOVWF NUMERATOR + 2
	MOVF V3, W
	MOVWF NUMERATOR + 3
	
	CALL DIVBY10 ;DISCARD
	CALL DIVBY10 ;THE LAST
	CALL DIVBY10 ;THREE DIGITS

	;SAVE THE 16BIT CURRENT NUM TO FIND AFTER THE WATTAGE
	MOVF  NUMERATOR + 0, W
	MOVWF CURRENT + 0
	MOVF  NUMERATOR + 1, W
	MOVWF CURRENT + 1
	
	CALL CONVERT2ASCII
	
	RETURN

;
;CALCULATES WATTAGE FROM THE ANALOG READINGS FOR CURRENT AND THE VOLTAGE AND THEN RETURNS THEM TO 5 REGISTERS
;	
CALC_WATTAGE:
	CLRF V0
	CLRF V1
	CLRF V2
	CLRF V3
	
	MOVF CURRENT + 0, W
	MOVWF CCL
	MOVF CURRENT + 1, W
	MOVWF CCH
	
	MOVF VOLTAGE + 0, W
	MOVWF CONVRESL
	MOVF VOLTAGE + 1, W
	MOVWF CONVRESH
	
	CALL AN2NUM

	MOVF V0, W
	MOVWF NUMERATOR + 0
	MOVF V1, W
	MOVWF NUMERATOR + 1
	MOVF V2, W
	MOVWF NUMERATOR + 2
	MOVF V3, W
	MOVWF NUMERATOR + 3
	
	CALL DIVBY10 ;DISCARD
	CALL DIVBY10 ;THE LAST
	CALL DIVBY10 ;THREE DIGITS

	CALL CONVERT2ASCII
	
	RETURN
;
;CONVERTS RESPONCE FROM A/D MODULE TO UVOLTS
;
AN2NUM:
	CLRF    V3
	CLRF	V2
	CLRF    V1
	MOVLW	0X80
	MOVWF	V0		

NEXTBIT
	RRF		CONVRESH,F
	RRF		CONVRESL,F

	BTFSS	STATUS, C
	GOTO	NOBIT_L
	MOVF	CCL,W
	ADDWF	V1,F

	MOVF	CCH, W
	BTFSC	STATUS, C
	INCFSZ	CCH, W	
	ADDWF	V2, F	
	BTFSC	STATUS, C
	INCF	V3, F
	BCF		STATUS, C
	
NOBIT_L	
	BTFSS	CONVRESL, 7
	GOTO	NOBIT_H
	MOVF	CCL,W
	ADDWF	V2,F
	MOVF	CCH, W
	BTFSC	STATUS, C
	INCFSZ	CCH, W
	ADDWF	V3, F	

NOBIT_H
	RRF		V3,F
	RRF		V2,F
	RRF		V1,F
	RRF		V0,F

	BTFSS   STATUS, C
	GOTO	NEXTBIT
	
	RETURN
	
;
;CONVERTS A 10 BIT ANALOG NUM TO 4 ASCII BYTES, THEN RETURNS THEM TO 4 REGISTERS
;
CONVERT2ASCII:
	;CONVERT 1ST DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_0
	
	;CONVERT 2ND DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_1
	
	;CONVERT 3RD DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_2
	
	;CONVERT 4TH DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_3
	
	;CONVERT LAST DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_4
	
	RETURN
	
;
;DIVIDES AN 32 BIT NUMBER BY 10 (0x0A), AND ALSO RETURNS THE REMAINDER
;
DIVBY10:
		MOVLW D'32' ; LOOP FOR 32 SHIFTS (WE HAVE 32BIT NUMERATOR)
		MOVWF LCNT ; LCNT IS THE LOOP COUNTER

		CLRF REMAINDER ; CLEAR REMAINDER REGISTER

		BCF STATUS, C ; CLEAR RESULT BIT
DIVBY10LOOP:
		RLF NUMERATOR + 0 ; ROLL RESULT BIT INTO NUMERATOR
		RLF NUMERATOR + 1
		RLF NUMERATOR + 2
		RLF NUMERATOR + 3
		RLF REMAINDER ; AND TOP BIT OF NUMERATOR INTO REMAINDER

		MOVLW D'10' ; CHECK IF REMAINDER (REMAINDER) >= 6
		SUBWF REMAINDER, W ; W = REMAINDER-6
		BTFSS STATUS, C ; CARRY SET IF REMAINDER >= 6
		GOTO DIVBY10NOGO

		MOVWF REMAINDER ; REMAINDER-6 (W) INTO REMAINDER
		; THE CARRY GETS ROLLED INTO NUMERATOR AS A RESULT
DIVBY10NOGO:
		DECFSZ LCNT, F ; LOOP UNTIL ALL BITS CHECKED
		GOTO DIVBY10LOOP
		RLF NUMERATOR + 0 ; ROLL LAST RESULT BIT INTO A
		RLF NUMERATOR + 1
		RLF NUMERATOR + 2
		RLF NUMERATOR + 3

		RETURN