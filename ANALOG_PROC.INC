;
;CONVERTS THE ANALOG READING FOR VOLTAGE TO VOLTS AND THEN RETURNS THEM TO 4 REGISTERS
;
CONVERT_VOLTAGE_TO_ASCII:
	CLRF V0
	CLRF V1
	CLRF V2
	
	MOVLW CCLV
	MOVWF CCL
	MOVLW CCHV
	MOVWF CCH
	
	CALL AN2NUM

	MOVF V0, W
	MOVWF NUMERATOR + 0
	MOVF V1, W
	MOVWF NUMERATOR + 1
	MOVF V2, W
	MOVWF NUMERATOR + 2
	CALL DIVBY10 ;DISCARD
	CALL DIVBY10 ;THE LAST
	CALL DIVBY10 ;THREE DIGITS

	CALL CONVERT2ASCII
	
	RETURN


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CONVERT_AMPS_TO_ASCII:	
	
	;INITIALIZING, NUMERATOR + 1 <-- ANIN1H, NUMERATOR + 0 <-- ANIN1L
	MOVF ANIN1H, W
	MOVWF CONVRESH
	MOVF ANIN1L, W
	MOVWF CONVRESL
	MOVLW D'2'	;INITIALING INPUT_PIN = DEC '1'
	MOVWF INPUT_PIN

	;WE ARE CHECKING IF HIGH BYTES ARE EQUAL
	MOVF ANIN1H,W
	IORWF ANIN2H
	BTFSC STATUS,Z	
	GOTO LOW_BYTE ;IF THEY ARE EQUAL, WE ARE CHECKING LOW BYTES
	
	;IF THEY ARE NOT EQUAL --> SUB THE HIGH BYTES OF 2 READINGS
	MOVF ANIN1H, W
	SUBWF ANIN2H, W
	BTFSS STATUS,C
	GOTO OK	; IF ANIN1H > ANIN2H GOTO OK

	MOVF ANIN2H, W	; IF ANIN2H > ANIN1H GOTO LOW_BYTE
	MOVWF CONVRESH
	MOVF ANIN2L, W	;
	MOVWF CONVRESL
	DECFSZ INPUT_PIN
	GOTO OK
	
	;SUB THE LOW BYTES TO FIND WHICH ONE IS BIGGER
LOW_BYTE:
	BCF STATUS,C
	MOVF ANIN1L, W
	SUBWF ANIN2L, W
	BTFSS STATUS,C
	GOTO OK
	MOVF ANIN2H, W	
	MOVWF CONVRESH	
	MOVF ANIN2L, W
	MOVWF CONVRESL
	DECFSZ INPUT_PIN
	

	;CONVERT TO ASCII AND OUTPUT TO THE LCD
OK:
	MOVLW B'00000011'
	ANDWF CONVRESH


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
	
	DECFSZ INPUT_PIN
	GOTO INPUT_PIN_A0
	
INPUT_PIN_A1:
	
	MOVLW CCLA1
	MOVWF CCL
	MOVLW CCHA1
	MOVWF CCH

	GOTO CONTINUE_2
	
INPUT_PIN_A0:

	MOVLW CCLA0
	MOVWF CCL
	MOVLW CCHA0
	MOVWF CCH
	

CONTINUE_2:
	CLRF V0
	CLRF V1
	CLRF V2
	
	CALL AN2NUM

	MOVF V0, W
	MOVWF NUMERATOR + 0
	MOVF V1, W
	MOVWF NUMERATOR + 1
	MOVF V2, W
	MOVWF NUMERATOR + 2
	CALL DIVBY10 ;DISCARD
	CALL DIVBY10 ;THE LAST
	CALL DIVBY10 ;THREE DIGITS

	CALL CONVERT2ASCII

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	RETURN
	
	
;
;CONVERTS RESPONCE FROM A/D MODULE TO UVOLTS
;
AN2NUM:
	MOVF CCL, W
	MOVWF CNT0
	MOVF CCH, W
	MOVWF CNT1

L1:

L0:
	MOVF CONVRESL, W ;ADRES LOW BYTE
	ADDWF V0
	BTFSC STATUS, C ;IF OVERFLOW
	GOTO INCV1
	GOTO NEXT1
INCV1:
	BCF STATUS, C
	MOVLW 0x01 ;ADD CARRY TO HIGHER BYTE
	ADDWF V1
	
NEXT1:
	BTFSC STATUS, C ;IF OVERFLOW AGAIN
	GOTO INCV2
	GOTO NEXT2
INCV2:
	BCF STATUS, C
	MOVLW 0x01 ;ADD CARRY TO HIGHEST BYTE
	ADDWF V2
	
NEXT2:
	MOVF CONVRESH, W ;ADRES HIGH BYTE
	ADDWF V1
	BTFSC STATUS, C ;IF OVERFLOW
	GOTO INCV22
	GOTO NEXT22
INCV22:
	BCF STATUS, C
	MOVLW 0x01 ;ADD CARRY TO HIGHEST BYTE
	ADDWF V2
NEXT22:

	DECFSZ CNT0
	GOTO L0

	MOVF CCL, W
	MOVWF CNT0
	DECFSZ CNT1
	GOTO L1

	RETURN
	
;
;CONVERTS A 10 BIT ANALOG NUM TO 4 ASCII BYTES, THEN RETURNS THEM TO 4 REGISTERS
;
CONVERT2ASCII:
	;CONVERT 1ST DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_0
	
	;CONVERT 2ND DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_1
	
	;CONVERT 3RD DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_2
	
	;CONVERT LAST DIGIT TO HEX
	CALL DIVBY10 ;DIVIDE BY 10 TO GET HEX VAL OF DIGIT
	MOVF REMAINDER, W
	CALL LCD_CHARD ;CONVERT HEX TO ASCII
	MOVWF V_ASCII_3
	
	RETURN
	
;
;DIVIDES AN 24 BIT NUMBER BY 10 (0x0A), AND ALSO RETURNS THE REMAINDER
;
DIVBY10:
		MOVLW D'24' ; LOOP FOR 24 SHIFTS (WE HAVE 24BIT NUMERATOR)
		MOVWF LCNT ; LCNT IS THE LOOP COUNTER

		CLRF REMAINDER ; CLEAR REMAINDER REGISTER

		BCF STATUS, C ; CLEAR RESULT BIT
DIVBY10LOOP:
		RLF NUMERATOR + 0 ; ROLL RESULT BIT INTO NUMERATOR
		RLF NUMERATOR + 1
		RLF NUMERATOR + 2
		RLF REMAINDER ; AND TOP BIT OF NUMERATOR INTO REMAINDER

		MOVLW D'10' ; CHECK IF REMAINDER (REMAINDER) >= 6
		SUBWF REMAINDER, W ; W = REMAINDER-6
		BTFSS STATUS, C ; CARRY SET IF REMAINDER >= 6
		GOTO DIVBY10NOGO

		MOVWF REMAINDER ; REMAINDER-6 (W) INTO REMAINDER
		; THE CARRY GETS ROLLED INTO NUMERATOR AS A RESULT
DIVBY10NOGO:
		DECFSZ LCNT, F ; LOOP UNTIL ALL BITS CHECKED
		GOTO DIVBY10LOOP
		RLF NUMERATOR + 0 ; ROLL LAST RESULT BIT INTO A
		RLF NUMERATOR + 1
		RLF NUMERATOR + 2

		RETURN